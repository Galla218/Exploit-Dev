# Write-What-Where
This writeup is for the purpose of my understanding of the write-what-where exploit abusing the lack of checks in the `unlink` function for earlier linux kernel versions 
using `dlmalloc`. This is performed with ASLR off.

## Dynamic Memory
When you call functions like `malloc` or `calloc`, you are dynamically creating chunks of memory on the heap. Standard function calls will utilize the stack because the variables
will only last within the scope of the function and can be torn down afterwards. Dynamically creating memory allows for the data to persist longer and allow the programmer or
garbage collector to free the memory when the program no longer requires it.

## dlmalloc()
Doug Lea's malloc is one such memory allocator and includes `malloc`, `calloc`, `realloc`, `free`, and other utility functions. The structure for a chunk of allocated memory is
diagramed below. An in-use chunk of memory contains a `Previous Size` field of 4 bytes and a `Size` field of 4 bytes. The `Prev_Size` field will contain the value 0 until the
adjacent chunk, lower in memory, is freed and no longer in use. The field will then contain the size of the adjacent chunk. The `Size` field will contain the size of the `Data` field. A free chunk will contain the `Prev_Size` and `Size` field along with a `Forward Pointer` and `Backward Pointer`. 

```
   Chunk in use                             Free chunk
------------------                       ------------------
:    Prev_Size   : 4 bytes               :   Prev_Size    : 4 bytes
:----------------:                       :----------------:
:      Size      : 4 bytes               :      Size      : 4 bytes
:----------------:                       :----------------:
:      Data      : variable in size      :     FD_Ptr     : 4 bytes
:                :                       :----------------:
:                :                       :     BK_Ptr     : 4 bytes
:                :                       :----------------:
:                :                       :    Old_Data    : variable in size
:                :                       :                :
------------------                       ------------------
```
Free chunks create a doubly linked list connecting all the free chunks together. When a chunk goes into use it unlinks itself from the list, or vice versa. More on this later.

`Size` will pad itself out to the next double word boundary so that it controlls the 3 least significant bits which will act as flags. The bit we are interested in is the least significant bit, which will contain the `Previous in Use` flag. When free is called on a chunk of memory, it will check the `P` flag for a 1 or a 0. If the bit is set to 1, it knows the adjacent chunk is in use. If 0, it knows the chunk is free. The heap does not allow two adjacent chunks to both be free. So if free is called on chunk1, it will see that chunk1's `P` bit is set and will merge chunk1 and chunk2 together. Keep in mind also that chunk1's `Prev_Size` field contains the size of chunk2 because chunk2
was freed and no longer in use.
```
                             Chunk 1                                                 Chunk 2 (Not in use)
-------------------------------------------------------------  -------------------------------------------------------------
:      Prev_Size      :   Size   |A|M|P|:       Data        :  : Prev_Size : Size |A|M|P|:  FD_Ptr  :  BK_Ptr  :  Old_Data :   
-------------------------------------------------------------  -------------------------------------------------------------
```
## What's the problem?
As mentioned earlier, when a chunk is freed from memory it gets put into a doubly linked list containing all the other free chunks. The chunks are inserted and removed from the linked list using `frontlink()` and `unlink()`. When `unlink()` is called it updates the adjacent free chunks forward pointer and backward pointer to update the linked list so that the chunks are no longer pointing to the chunk which just got put into use.
```C
#define unlink(P, BK, FD) {
	FD = P->fd;
	BK = P->bk;
	FD->bk = BK;
	BK-fd = FD;
}
```
The issue is the last two lines where unlink goes to `FD` (forward adjacent chunk) and `BK` (backward adjacent chunk) and updates their pointers with `P`'s pointers. Unlink is not checking to make sure the pointers that `P` holds actually belong to `P`. What happens if you can overwrite a chunk which gets freed with your own forward and backward pointers?
## Exploit
Without looking at the source code of our vulnerable program, we can run `objdump -R` on it to see the functions from shared libraries that are loaded.
```
ubuntu@ubuntu:~$ objdump -R ./vuln

./vuln:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
080496d4 R_386_GLOB_DAT    __gmon_start__
080496b8 R_386_JUMP_SLOT   malloc@GLIBC_2.0
080496bc R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
080496c0 R_386_JUMP_SLOT   printf@GLIBC_2.0
080496c4 R_386_JUMP_SLOT   exit@GLIBC_2.0
080496c8 R_386_JUMP_SLOT   free@GLIBC_2.0
080496cc R_386_JUMP_SLOT   memset@GLIBC_2.0
080496d0 R_386_JUMP_SLOT   strcpy@GLIBC_2.0
```
We can see that `malloc` and `strcpy` are both loaded. Running `ltrace` we can see the addresses of where `malloc` is being called and how large the allocations are. Keep in mind ASLR is turned off.
```
ubuntu@ubuntu:~$ ltrace 2>&1 ./vuln | grep malloc
malloc(300)                                      = 0x804a008
malloc(300)                                      = 0x804a138
malloc(300)                                      = 0x804a268
```
Let's run the program and see if we can get it to crash. We know the allocations are 300 bytes so lets try something larger than 300.
```
ubuntu@ubuntu:~$ ./vuln
Usage: ./vuln <Enter a string to copy into memory.>
ubuntu@ubuntu:~$ ./vuln AAAAAAAAAA
Thanks!
ubuntu@ubuntu:~$ ./vuln `python -c 'print("A" * 350)'`
Segmentation fault (core dumped)
```
Now that we know we can get the program to segfault, lets throw it into gdb and start debugging. 

Let's start by taking a look at a normal run of the program and inspecting the structures mentioned above.
```gdb
ubuntu@ubuntu:~$ gdb ./vuln
gef➤ break main
gef➤  r `python -c 'print("A"*296)'`
gef➤  disass main                                                                                                                                                                                  [25/1904]
Dump of assembler code for function main:                                                                                                                                                                  
   0x0804842c <+0>:     push   ebp                                                                                                                                                                         
   0x0804842d <+1>:     mov    ebp,esp                                                                                                                                                                     
   0x0804842f <+3>:     sub    esp,0x18                                                                                                                                                                    
=> 0x08048432 <+6>:     and    esp,0xfffffff0                                                                                                                                                              
   0x08048435 <+9>:     mov    eax,0x0                                                                                                                                                                     
   0x0804843a <+14>:    sub    esp,eax                                                                                                                                                                     
   0x0804843c <+16>:    sub    esp,0xc                                                                                                                                                                     
   0x0804843f <+19>:    push   0x12c                                                                                                                                                                       
   0x08048444 <+24>:    call   0x804830c <malloc@plt>                                                                                                                                                      
   0x08048449 <+29>:    add    esp,0x10                                                                                                                                                                    
   0x0804844c <+32>:    mov    DWORD PTR [ebp-0x4],eax                                                                                                                                                     
   0x0804844f <+35>:    sub    esp,0x4                                                                                                                                                                     
   0x08048452 <+38>:    push   0x12c                                                                                                                                                                       
   0x08048457 <+43>:    push   0x0                                                                                                                                                                         
   0x08048459 <+45>:    push   DWORD PTR [ebp-0x4]                                                                                                                                                         
   0x0804845c <+48>:    call   0x804835c <memset@plt>                                                                                                                                                      
   0x08048461 <+53>:    add    esp,0x10                                                                                                                                                                    
   0x08048464 <+56>:    sub    esp,0xc                                                                                                                                                                     
   0x08048467 <+59>:    push   0x12c                                                                                                                                                                       
   0x0804846c <+64>:    call   0x804830c <malloc@plt>                                                                                                                                                      
   0x08048471 <+69>:    add    esp,0x10                                                                                                                                                                    
   0x08048474 <+72>:    mov    DWORD PTR [ebp-0x8],eax                                                                                                                                                     
   0x08048477 <+75>:    sub    esp,0x4                                                                                                                                                                     
   0x0804847a <+78>:    push   0x12c                                                                                                                                                                 
   0x0804847f <+83>:    push   0x0
   0x08048481 <+85>:    push   DWORD PTR [ebp-0x8]
   0x08048484 <+88>:    call   0x804835c <memset@plt>
   0x08048489 <+93>:    add    esp,0x10
   0x0804848c <+96>:    sub    esp,0xc
   0x0804848f <+99>:    push   0x12c
   0x08048494 <+104>:   call   0x804830c <malloc@plt>
   0x08048499 <+109>:   add    esp,0x10
   0x0804849c <+112>:   mov    DWORD PTR [ebp-0xc],eax
   0x0804849f <+115>:   sub    esp,0x4
   0x080484a2 <+118>:   push   0x12c
   0x080484a7 <+123>:   push   0x0
   0x080484a9 <+125>:   push   DWORD PTR [ebp-0xc]
   0x080484ac <+128>:   call   0x804835c <memset@plt>
   0x080484b1 <+133>:   add    esp,0x10
   0x080484b4 <+136>:   cmp    DWORD PTR [ebp+0x8],0x2
   0x080484b8 <+140>:   je     0x80484d4 <main+168>
   0x080484ba <+142>:   sub    esp,0xc
   0x080484bd <+145>:   push   0x8048580
   0x080484c2 <+150>:   call   0x804832c <printf@plt>
   0x080484c7 <+155>:   add    esp,0x10
   0x080484ca <+158>:   sub    esp,0xc
   0x080484cd <+161>:   push   0x1
   0x080484cf <+163>:   call   0x804833c <exit@plt>
   0x080484d4 <+168>:   sub    esp,0x8
   0x080484d7 <+171>:   mov    eax,DWORD PTR [ebp+0xc]
   0x080484da <+174>:   add    eax,0x4
   0x080484dd <+177>:   push   DWORD PTR [eax]
   0x080484df <+179>:   push   DWORD PTR [ebp-0x4]
   0x080484e2 <+182>:   call   0x804836c <strcpy@plt>
   0x080484e7 <+187>:   add    esp,0x10
   0x080484ea <+190>:   sub    esp,0xc
   0x080484ed <+193>:   push   0x80485b6
   0x080484f2 <+198>:   call   0x804832c <printf@plt>
   0x080484f7 <+203>:   add    esp,0x10
   0x080484fa <+206>:   sub    esp,0xc
   0x080484fd <+209>:   push   DWORD PTR [ebp-0x8]
   0x08048500 <+212>:   call   0x804834c <free@plt>
   0x08048505 <+217>:   add    esp,0x10
   0x08048508 <+220>:   sub    esp,0xc
   0x0804850b <+223>:   push   0x0
   0x0804850d <+225>:   call   0x804833c <exit@plt>
End of assembler dump.
```
Doing a `disassemble main` shows us that first the program is calling three seperate `malloc` then `memset` iterations, a branch to call `printf` and then `exit`,
or a call to `strcpy` and then `printf`, `free`, and `exit`. We can assume our vulnerable piece of code is the call to `strcpy` and explain why we get a segfault
when inputting >300 characters. Now lets walk through and keep an eye on the 3 address we got from the ltrace output for our `malloc` calls.

```gdb
gef➤  break *0x080484e2                                                                                                                                                                                    
Breakpoint 2 at 0x80484e2                                                                                                                                                                                  
gef➤  break *0x08048500                                                                                                                                                                                    
Breakpoint 3 at 0x8048500                                                                                                                                                                                  
gef➤  c                                                                                                                                                                                                    
Continuing.
...
gef➤  x/10x 0x804a008
0x804a008:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a018:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a028:      0x00000000      0x00000000
gef➤  x/10x 0x804a138
0x804a138:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a148:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a158:      0x00000000      0x00000000
gef➤  x/10x 0x804a268
0x804a268:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a278:      0x00000000      0x00000000      0x00000000      0x00000000
0x804a288:      0x00000000      0x00000000
```
First lets set a break point on our call to `strcpy` and `free` in `main` and continue execution. Now inspecting our three addresses we can see no data has been
copied over yet.

```gdb
gef➤  s
gef➤  x/8x 0x804a008
0x804a008:      0x41414141      0x41414141      0x41414141      0x41414141
0x804a018:      0x41414141      0x41414141      0x41414141      0x41414141
```
We can see that our A's were copied over into the first block. Viewing 8 bytes above of the address will show us the `Prev_Size` and `Size` fields.
```gdb
gef➤  x/8x 0x804a008-8                                                                                                                                                                                     
0x804a000:      0x00000000      0x00000131      0x41414141      0x41414141
0x804a010:      0x41414141      0x41414141      0x41414141      0x41414141
```
Both fields are 4 bytes in size so our `Prev_Size` field is `0x00000000` which makes sense because a chunk lower in memory has not been freed yet. And our `Size` field is `0x00000131` which converted from hex equals 305. If you recall from our ltrace, `malloc` was called with a value of 300. So why is our size 305? Because its padding itself out to have controll of the 3 least significant bits to store our flags.
